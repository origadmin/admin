// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: casbin/casbin.proto

package casbin

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ListPoliciesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPoliciesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPoliciesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPoliciesRequestMultiError, or nil if none found.
func (m *ListPoliciesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPoliciesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListPoliciesRequestMultiError(errors)
	}

	return nil
}

// ListPoliciesRequestMultiError is an error wrapping multiple validation
// errors returned by ListPoliciesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListPoliciesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPoliciesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPoliciesRequestMultiError) AllErrors() []error { return m }

// ListPoliciesRequestValidationError is the validation error returned by
// ListPoliciesRequest.Validate if the designated constraints aren't met.
type ListPoliciesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPoliciesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPoliciesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPoliciesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPoliciesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPoliciesRequestValidationError) ErrorName() string {
	return "ListPoliciesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListPoliciesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPoliciesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPoliciesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPoliciesRequestValidationError{}

// Validate checks the field values on ListPoliciesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPoliciesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPoliciesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPoliciesResponseMultiError, or nil if none found.
func (m *ListPoliciesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPoliciesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPoliciesResponseValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPoliciesResponseValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPoliciesResponseValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListPoliciesResponseMultiError(errors)
	}

	return nil
}

// ListPoliciesResponseMultiError is an error wrapping multiple validation
// errors returned by ListPoliciesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListPoliciesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPoliciesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPoliciesResponseMultiError) AllErrors() []error { return m }

// ListPoliciesResponseValidationError is the validation error returned by
// ListPoliciesResponse.Validate if the designated constraints aren't met.
type ListPoliciesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPoliciesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPoliciesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPoliciesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPoliciesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPoliciesResponseValidationError) ErrorName() string {
	return "ListPoliciesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListPoliciesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPoliciesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPoliciesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPoliciesResponseValidationError{}

// Validate checks the field values on PolicyRule with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PolicyRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PolicyRule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PolicyRuleMultiError, or
// nil if none found.
func (m *PolicyRule) ValidateAll() error {
	return m.validate(true)
}

func (m *PolicyRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ptype

	if len(errors) > 0 {
		return PolicyRuleMultiError(errors)
	}

	return nil
}

// PolicyRuleMultiError is an error wrapping multiple validation errors
// returned by PolicyRule.ValidateAll() if the designated constraints aren't met.
type PolicyRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolicyRuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolicyRuleMultiError) AllErrors() []error { return m }

// PolicyRuleValidationError is the validation error returned by
// PolicyRule.Validate if the designated constraints aren't met.
type PolicyRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolicyRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolicyRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolicyRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolicyRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolicyRuleValidationError) ErrorName() string { return "PolicyRuleValidationError" }

// Error satisfies the builtin error interface
func (e PolicyRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolicyRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolicyRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolicyRuleValidationError{}

// Validate checks the field values on ListGroupingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListGroupingsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListGroupingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListGroupingsRequestMultiError, or nil if none found.
func (m *ListGroupingsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListGroupingsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListGroupingsRequestMultiError(errors)
	}

	return nil
}

// ListGroupingsRequestMultiError is an error wrapping multiple validation
// errors returned by ListGroupingsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListGroupingsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListGroupingsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListGroupingsRequestMultiError) AllErrors() []error { return m }

// ListGroupingsRequestValidationError is the validation error returned by
// ListGroupingsRequest.Validate if the designated constraints aren't met.
type ListGroupingsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListGroupingsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListGroupingsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListGroupingsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListGroupingsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListGroupingsRequestValidationError) ErrorName() string {
	return "ListGroupingsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListGroupingsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListGroupingsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListGroupingsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListGroupingsRequestValidationError{}

// Validate checks the field values on ListGroupingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListGroupingsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListGroupingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListGroupingsResponseMultiError, or nil if none found.
func (m *ListGroupingsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListGroupingsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListGroupingsResponseValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListGroupingsResponseValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListGroupingsResponseValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListGroupingsResponseMultiError(errors)
	}

	return nil
}

// ListGroupingsResponseMultiError is an error wrapping multiple validation
// errors returned by ListGroupingsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListGroupingsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListGroupingsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListGroupingsResponseMultiError) AllErrors() []error { return m }

// ListGroupingsResponseValidationError is the validation error returned by
// ListGroupingsResponse.Validate if the designated constraints aren't met.
type ListGroupingsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListGroupingsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListGroupingsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListGroupingsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListGroupingsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListGroupingsResponseValidationError) ErrorName() string {
	return "ListGroupingsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListGroupingsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListGroupingsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListGroupingsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListGroupingsResponseValidationError{}

// Validate checks the field values on GroupingRule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GroupingRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupingRule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GroupingRuleMultiError, or
// nil if none found.
func (m *GroupingRule) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupingRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ptype

	if len(errors) > 0 {
		return GroupingRuleMultiError(errors)
	}

	return nil
}

// GroupingRuleMultiError is an error wrapping multiple validation errors
// returned by GroupingRule.ValidateAll() if the designated constraints aren't met.
type GroupingRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupingRuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupingRuleMultiError) AllErrors() []error { return m }

// GroupingRuleValidationError is the validation error returned by
// GroupingRule.Validate if the designated constraints aren't met.
type GroupingRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupingRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupingRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupingRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupingRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupingRuleValidationError) ErrorName() string { return "GroupingRuleValidationError" }

// Error satisfies the builtin error interface
func (e GroupingRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupingRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupingRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupingRuleValidationError{}

// Validate checks the field values on StreamRulesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StreamRulesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamRulesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StreamRulesRequestMultiError, or nil if none found.
func (m *StreamRulesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamRulesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WithPolicies

	// no validation rules for WithGroupings

	if len(errors) > 0 {
		return StreamRulesRequestMultiError(errors)
	}

	return nil
}

// StreamRulesRequestMultiError is an error wrapping multiple validation errors
// returned by StreamRulesRequest.ValidateAll() if the designated constraints
// aren't met.
type StreamRulesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamRulesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamRulesRequestMultiError) AllErrors() []error { return m }

// StreamRulesRequestValidationError is the validation error returned by
// StreamRulesRequest.Validate if the designated constraints aren't met.
type StreamRulesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamRulesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamRulesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamRulesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamRulesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamRulesRequestValidationError) ErrorName() string {
	return "StreamRulesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StreamRulesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamRulesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamRulesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamRulesRequestValidationError{}

// Validate checks the field values on StreamRulesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StreamRulesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamRulesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StreamRulesResponseMultiError, or nil if none found.
func (m *StreamRulesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamRulesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.RuleType.(type) {
	case *StreamRulesResponse_Policy:
		if v == nil {
			err := StreamRulesResponseValidationError{
				field:  "RuleType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPolicy()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StreamRulesResponseValidationError{
						field:  "Policy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StreamRulesResponseValidationError{
						field:  "Policy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPolicy()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StreamRulesResponseValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *StreamRulesResponse_Grouping:
		if v == nil {
			err := StreamRulesResponseValidationError{
				field:  "RuleType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGrouping()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StreamRulesResponseValidationError{
						field:  "Grouping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StreamRulesResponseValidationError{
						field:  "Grouping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGrouping()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StreamRulesResponseValidationError{
					field:  "Grouping",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return StreamRulesResponseMultiError(errors)
	}

	return nil
}

// StreamRulesResponseMultiError is an error wrapping multiple validation
// errors returned by StreamRulesResponse.ValidateAll() if the designated
// constraints aren't met.
type StreamRulesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamRulesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamRulesResponseMultiError) AllErrors() []error { return m }

// StreamRulesResponseValidationError is the validation error returned by
// StreamRulesResponse.Validate if the designated constraints aren't met.
type StreamRulesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamRulesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamRulesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamRulesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamRulesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamRulesResponseValidationError) ErrorName() string {
	return "StreamRulesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StreamRulesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamRulesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamRulesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamRulesResponseValidationError{}
